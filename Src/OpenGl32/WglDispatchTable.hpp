//
// Created by arthur on 23/04/2025.
//

#pragma once
#include "OpenGl32/Defines.hpp"

namespace glgpus
{
	// From gldrv.h https://learn.microsoft.com/fr-fr/windows-hardware/drivers/download-the-wdk
	struct WglDispatchTable
	{
		//OpenGl 1.0
		void(CCT_CALL* glNewList)(GLuint list, GLenum mode);
		void(CCT_CALL* glEndList)();
		void(CCT_CALL* glCallList)(GLuint list);
		void(CCT_CALL* glCallLists)(GLsizei n, GLenum type, const GLvoid* lists);
		void(CCT_CALL* glDeleteLists)(GLuint list, GLsizei range);
		GLuint(CCT_CALL* glGenLists)(GLsizei range);
		void(CCT_CALL* glListBase)(GLuint base);
		void(CCT_CALL* glBegin)(GLenum mode);
		void(CCT_CALL* glBitmap)(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte* bitmap);
		void(CCT_CALL* glColor3b)(GLbyte red, GLbyte green, GLbyte blue);
		void(CCT_CALL* glColor3bv)(const GLbyte* v);
		void(CCT_CALL* glColor3d)(GLdouble red, GLdouble green, GLdouble blue);
		void(CCT_CALL* glColor3dv)(const GLdouble* v);
		void(CCT_CALL* glColor3f)(GLfloat red, GLfloat green, GLfloat blue);
		void(CCT_CALL* glColor3fv)(const GLfloat* v);
		void(CCT_CALL* glColor3i)(GLint red, GLint green, GLint blue);
		void(CCT_CALL* glColor3iv)(const GLint* v);
		void(CCT_CALL* glColor3s)(GLshort red, GLshort green, GLshort blue);
		void(CCT_CALL* glColor3sv)(const GLshort* v);
		void(CCT_CALL* glColor3ub)(GLubyte red, GLubyte green, GLubyte blue);
		void(CCT_CALL* glColor3ubv)(const GLubyte* v);
		void(CCT_CALL* glColor3ui)(GLuint red, GLuint green, GLuint blue);
		void(CCT_CALL* glColor3uiv)(const GLuint* v);
		void(CCT_CALL* glColor3us)(GLushort red, GLushort green, GLushort blue);
		void(CCT_CALL* glColor3usv)(const GLushort* v);
		void(CCT_CALL* glColor4b)(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
		void(CCT_CALL* glColor4bv)(const GLbyte* v);
		void(CCT_CALL* glColor4d)(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
		void(CCT_CALL* glColor4dv)(const GLdouble* v);
		void(CCT_CALL* glColor4f)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
		void(CCT_CALL* glColor4fv)(const GLfloat* v);
		void(CCT_CALL* glColor4i)(GLint red, GLint green, GLint blue, GLint alpha);
		void(CCT_CALL* glColor4iv)(const GLint* v);
		void(CCT_CALL* glColor4s)(GLshort red, GLshort green, GLshort blue, GLshort alpha);
		void(CCT_CALL* glColor4sv)(const GLshort* v);
		void(CCT_CALL* glColor4ub)(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
		void(CCT_CALL* glColor4ubv)(const GLubyte* v);
		void(CCT_CALL* glColor4ui)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
		void(CCT_CALL* glColor4uiv)(const GLuint* v);
		void(CCT_CALL* glColor4us)(GLushort red, GLushort green, GLushort blue, GLushort alpha);
		void(CCT_CALL* glColor4usv)(const GLushort* v);
		void(CCT_CALL* glEdgeFlag)(GLboolean flag);
		void(CCT_CALL* glEdgeFlagv)(const GLboolean* flag);
		void(CCT_CALL* glEnd)();
		void(CCT_CALL* glIndexd)(GLdouble c);
		void(CCT_CALL* glIndexdv)(const GLdouble* c);
		void(CCT_CALL* glIndexf)(GLfloat c);
		void(CCT_CALL* glIndexfv)(const GLfloat* c);
		void(CCT_CALL* glIndexi)(GLint c);
		void(CCT_CALL* glIndexiv)(const GLint* c);
		void(CCT_CALL* glIndexs)(GLshort c);
		void(CCT_CALL* glIndexsv)(const GLshort* c);
		void(CCT_CALL* glNormal3b)(GLbyte nx, GLbyte ny, GLbyte nz);
		void(CCT_CALL* glNormal3bv)(const GLbyte* v);
		void(CCT_CALL* glNormal3d)(GLdouble nx, GLdouble ny, GLdouble nz);
		void(CCT_CALL* glNormal3dv)(const GLdouble* v);
		void(CCT_CALL* glNormal3f)(GLfloat nx, GLfloat ny, GLfloat nz);
		void(CCT_CALL* glNormal3fv)(const GLfloat* v);
		void(CCT_CALL* glNormal3i)(GLint nx, GLint ny, GLint nz);
		void(CCT_CALL* glNormal3iv)(const GLint* v);
		void(CCT_CALL* glNormal3s)(GLshort nx, GLshort ny, GLshort nz);
		void(CCT_CALL* glNormal3sv)(const GLshort* v);
		void(CCT_CALL* glRasterPos2d)(GLdouble x, GLdouble y);
		void(CCT_CALL* glRasterPos2dv)(const GLdouble* v);
		void(CCT_CALL* glRasterPos2f)(GLfloat x, GLfloat y);
		void(CCT_CALL* glRasterPos2fv)(const GLfloat* v);
		void(CCT_CALL* glRasterPos2i)(GLint x, GLint y);
		void(CCT_CALL* glRasterPos2iv)(const GLint* v);
		void(CCT_CALL* glRasterPos2s)(GLshort x, GLshort y);
		void(CCT_CALL* glRasterPos2sv)(const GLshort* v);
		void(CCT_CALL* glRasterPos3d)(GLdouble x, GLdouble y, GLdouble z);
		void(CCT_CALL* glRasterPos3dv)(const GLdouble* v);
		void(CCT_CALL* glRasterPos3f)(GLfloat x, GLfloat y, GLfloat z);
		void(CCT_CALL* glRasterPos3fv)(const GLfloat* v);
		void(CCT_CALL* glRasterPos3i)(GLint x, GLint y, GLint z);
		void(CCT_CALL* glRasterPos3iv)(const GLint* v);
		void(CCT_CALL* glRasterPos3s)(GLshort x, GLshort y, GLshort z);
		void(CCT_CALL* glRasterPos3sv)(const GLshort* v);
		void(CCT_CALL* glRasterPos4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
		void(CCT_CALL* glRasterPos4dv)(const GLdouble* v);
		void(CCT_CALL* glRasterPos4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
		void(CCT_CALL* glRasterPos4fv)(const GLfloat* v);
		void(CCT_CALL* glRasterPos4i)(GLint x, GLint y, GLint z, GLint w);
		void(CCT_CALL* glRasterPos4iv)(const GLint* v);
		void(CCT_CALL* glRasterPos4s)(GLshort x, GLshort y, GLshort z, GLshort w);
		void(CCT_CALL* glRasterPos4sv)(const GLshort* v);
		void(CCT_CALL* glRectd)(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
		void(CCT_CALL* glRectdv)(const GLdouble* v1, const GLdouble* v2);
		void(CCT_CALL* glRectf)(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
		void(CCT_CALL* glRectfv)(const GLfloat* v1, const GLfloat* v2);
		void(CCT_CALL* glRecti)(GLint x1, GLint y1, GLint x2, GLint y2);
		void(CCT_CALL* glRectiv)(const GLint* v1, const GLint* v2);
		void(CCT_CALL* glRects)(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
		void(CCT_CALL* glRectsv)(const GLshort* v1, const GLshort* v2);
		void(CCT_CALL* glTexCoord1d)(GLdouble s);
		void(CCT_CALL* glTexCoord1dv)(const GLdouble* v);
		void(CCT_CALL* glTexCoord1f)(GLfloat s);
		void(CCT_CALL* glTexCoord1fv)(const GLfloat* v);
		void(CCT_CALL* glTexCoord1i)(GLint s);
		void(CCT_CALL* glTexCoord1iv)(const GLint* v);
		void(CCT_CALL* glTexCoord1s)(GLshort s);
		void(CCT_CALL* glTexCoord1sv)(const GLshort* v);
		void(CCT_CALL* glTexCoord2d)(GLdouble s, GLdouble t);
		void(CCT_CALL* glTexCoord2dv)(const GLdouble* v);
		void(CCT_CALL* glTexCoord2f)(GLfloat s, GLfloat t);
		void(CCT_CALL* glTexCoord2fv)(const GLfloat* v);
		void(CCT_CALL* glTexCoord2i)(GLint s, GLint t);
		void(CCT_CALL* glTexCoord2iv)(const GLint* v);
		void(CCT_CALL* glTexCoord2s)(GLshort s, GLshort t);
		void(CCT_CALL* glTexCoord2sv)(const GLshort* v);
		void(CCT_CALL* glTexCoord3d)(GLdouble s, GLdouble t, GLdouble r);
		void(CCT_CALL* glTexCoord3dv)(const GLdouble* v);
		void(CCT_CALL* glTexCoord3f)(GLfloat s, GLfloat t, GLfloat r);
		void(CCT_CALL* glTexCoord3fv)(const GLfloat* v);
		void(CCT_CALL* glTexCoord3i)(GLint s, GLint t, GLint r);
		void(CCT_CALL* glTexCoord3iv)(const GLint* v);
		void(CCT_CALL* glTexCoord3s)(GLshort s, GLshort t, GLshort r);
		void(CCT_CALL* glTexCoord3sv)(const GLshort* v);
		void(CCT_CALL* glTexCoord4d)(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
		void(CCT_CALL* glTexCoord4dv)(const GLdouble* v);
		void(CCT_CALL* glTexCoord4f)(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
		void(CCT_CALL* glTexCoord4fv)(const GLfloat* v);
		void(CCT_CALL* glTexCoord4i)(GLint s, GLint t, GLint r, GLint q);
		void(CCT_CALL* glTexCoord4iv)(const GLint* v);
		void(CCT_CALL* glTexCoord4s)(GLshort s, GLshort t, GLshort r, GLshort q);
		void(CCT_CALL* glTexCoord4sv)(const GLshort* v);
		void(CCT_CALL* glVertex2d)(GLdouble x, GLdouble y);
		void(CCT_CALL* glVertex2dv)(const GLdouble* v);
		void(CCT_CALL* glVertex2f)(GLfloat x, GLfloat y);
		void(CCT_CALL* glVertex2fv)(const GLfloat* v);
		void(CCT_CALL* glVertex2i)(GLint x, GLint y);
		void(CCT_CALL* glVertex2iv)(const GLint* v);
		void(CCT_CALL* glVertex2s)(GLshort x, GLshort y);
		void(CCT_CALL* glVertex2sv)(const GLshort* v);
		void(CCT_CALL* glVertex3d)(GLdouble x, GLdouble y, GLdouble z);
		void(CCT_CALL* glVertex3dv)(const GLdouble* v);
		void(CCT_CALL* glVertex3f)(GLfloat x, GLfloat y, GLfloat z);
		void(CCT_CALL* glVertex3fv)(const GLfloat* v);
		void(CCT_CALL* glVertex3i)(GLint x, GLint y, GLint z);
		void(CCT_CALL* glVertex3iv)(const GLint* v);
		void(CCT_CALL* glVertex3s)(GLshort x, GLshort y, GLshort z);
		void(CCT_CALL* glVertex3sv)(const GLshort* v);
		void(CCT_CALL* glVertex4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
		void(CCT_CALL* glVertex4dv)(const GLdouble* v);
		void(CCT_CALL* glVertex4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
		void(CCT_CALL* glVertex4fv)(const GLfloat* v);
		void(CCT_CALL* glVertex4i)(GLint x, GLint y, GLint z, GLint w);
		void(CCT_CALL* glVertex4iv)(const GLint* v);
		void(CCT_CALL* glVertex4s)(GLshort x, GLshort y, GLshort z, GLshort w);
		void(CCT_CALL* glVertex4sv)(const GLshort* v);
		void(CCT_CALL* glClipPlane)(GLenum plane, const GLdouble* equation);
		void(CCT_CALL* glColorMaterial)(GLenum face, GLenum mode);
		void(CCT_CALL* glCullFace)(GLenum mode);
		void(CCT_CALL* glFogf)(GLenum pname, GLfloat param);
		void(CCT_CALL* glFogfv)(GLenum pname, const GLfloat* params);
		void(CCT_CALL* glFogi)(GLenum pname, GLint param);
		void(CCT_CALL* glFogiv)(GLenum pname, const GLint* params);
		void(CCT_CALL* glFrontFace)(GLenum mode);
		void(CCT_CALL* glHint)(GLenum target, GLenum mode);
		void(CCT_CALL* glLightf)(GLenum light, GLenum pname, GLfloat param);
		void(CCT_CALL* glLightfv)(GLenum light, GLenum pname, const GLfloat* params);
		void(CCT_CALL* glLighti)(GLenum light, GLenum pname, GLint param);
		void(CCT_CALL* glLightiv)(GLenum light, GLenum pname, const GLint* params);
		void(CCT_CALL* glLightModelf)(GLenum pname, GLfloat param);
		void(CCT_CALL* glLightModelfv)(GLenum pname, const GLfloat* params);
		void(CCT_CALL* glLightModeli)(GLenum pname, GLint param);
		void(CCT_CALL* glLightModeliv)(GLenum pname, const GLint* params);
		void(CCT_CALL* glLineStipple)(GLint factor, GLushort pattern);
		void(CCT_CALL* glLineWidth)(GLfloat width);
		void(CCT_CALL* glMaterialf)(GLenum face, GLenum pname, GLfloat param);
		void(CCT_CALL* glMaterialfv)(GLenum face, GLenum pname, const GLfloat* params);
		void(CCT_CALL* glMateriali)(GLenum face, GLenum pname, GLint param);
		void(CCT_CALL* glMaterialiv)(GLenum face, GLenum pname, const GLint* params);
		void(CCT_CALL* glPointSize)(GLfloat size);
		void(CCT_CALL* glPolygonMode)(GLenum face, GLenum mode);
		void(CCT_CALL* glPolygonStipple)(const GLubyte* mask);
		void(CCT_CALL* glScissor)(GLint x, GLint y, GLsizei width, GLsizei height);
		void(CCT_CALL* glShadeModel)(GLenum mode);
		void(CCT_CALL* glTexParameterf)(GLenum target, GLenum pname, GLfloat param);
		void(CCT_CALL* glTexParameterfv)(GLenum target, GLenum pname, const GLfloat* params);
		void(CCT_CALL* glTexParameteri)(GLenum target, GLenum pname, GLint param);
		void(CCT_CALL* glTexParameteriv)(GLenum target, GLenum pname, const GLint* params);
		void(CCT_CALL* glTexImage1D)(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
		void(CCT_CALL* glTexImage2D)(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
		void(CCT_CALL* glTexEnvf)(GLenum target, GLenum pname, GLfloat param);
		void(CCT_CALL* glTexEnvfv)(GLenum target, GLenum pname, const GLfloat* params);
		void(CCT_CALL* glTexEnvi)(GLenum target, GLenum pname, GLint param);
		void(CCT_CALL* glTexEnviv)(GLenum target, GLenum pname, const GLint* params);
		void(CCT_CALL* glTexGend)(GLenum coord, GLenum pname, GLdouble param);
		void(CCT_CALL* glTexGendv)(GLenum coord, GLenum pname, const GLdouble* params);
		void(CCT_CALL* glTexGenf)(GLenum coord, GLenum pname, GLfloat param);
		void(CCT_CALL* glTexGenfv)(GLenum coord, GLenum pname, const GLfloat* params);
		void(CCT_CALL* glTexGeni)(GLenum coord, GLenum pname, GLint param);
		void(CCT_CALL* glTexGeniv)(GLenum coord, GLenum pname, const GLint* params);
		void(CCT_CALL* glFeedbackBuffer)(GLsizei size, GLenum type, GLfloat* buffer);
		void(CCT_CALL* glSelectBuffer)(GLsizei size, GLuint* buffer);
		GLint(CCT_CALL* glRenderMode)(GLenum mode);
		void(CCT_CALL* glInitNames)();
		void(CCT_CALL* glLoadName)(GLuint name);
		void(CCT_CALL* glPassThrough)(GLfloat token);
		void(CCT_CALL* glPopName)();
		void(CCT_CALL* glPushName)(GLuint name);
		void(CCT_CALL* glDrawBuffer)(GLenum mode);
		void(CCT_CALL* glClear)(GLbitfield mask);
		void(CCT_CALL* glClearAccum)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
		void(CCT_CALL* glClearIndex)(GLfloat c);
		void(CCT_CALL* glClearColor)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
		void(CCT_CALL* glClearStencil)(GLint s);
		void(CCT_CALL* glClearDepth)(GLclampd depth);
		void(CCT_CALL* glStencilMask)(GLuint mask);
		void(CCT_CALL* glColorMask)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
		void(CCT_CALL* glDepthMask)(GLboolean flag);
		void(CCT_CALL* glIndexMask)(GLuint mask);
		void(CCT_CALL* glAccum)(GLenum op, GLfloat value);
		void(CCT_CALL* glDisable)(GLenum cap);
		void(CCT_CALL* glEnable)(GLenum cap);
		void(CCT_CALL* glFinish)();
		void(CCT_CALL* glFlush)();
		void(CCT_CALL* glPopAttrib)();
		void(CCT_CALL* glPushAttrib)(GLbitfield mask);
		void(CCT_CALL* glMap1d)(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
		void(CCT_CALL* glMap1f)(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
		void(CCT_CALL* glMap2d)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
		void(CCT_CALL* glMap2f)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);
		void(CCT_CALL* glMapGrid1d)(GLint un, GLdouble u1, GLdouble u2);
		void(CCT_CALL* glMapGrid1f)(GLint un, GLfloat u1, GLfloat u2);
		void(CCT_CALL* glMapGrid2d)(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
		void(CCT_CALL* glMapGrid2f)(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
		void(CCT_CALL* glEvalCoord1d)(GLdouble u);
		void(CCT_CALL* glEvalCoord1dv)(const GLdouble* u);
		void(CCT_CALL* glEvalCoord1f)(GLfloat u);
		void(CCT_CALL* glEvalCoord1fv)(const GLfloat* u);
		void(CCT_CALL* glEvalCoord2d)(GLdouble u, GLdouble v);
		void(CCT_CALL* glEvalCoord2dv)(const GLdouble* u);
		void(CCT_CALL* glEvalCoord2f)(GLfloat u, GLfloat v);
		void(CCT_CALL* glEvalCoord2fv)(const GLfloat* u);
		void(CCT_CALL* glEvalMesh1)(GLenum mode, GLint i1, GLint i2);
		void(CCT_CALL* glEvalPoint1)(GLint i);
		void(CCT_CALL* glEvalMesh2)(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
		void(CCT_CALL* glEvalPoint2)(GLint i, GLint j);
		void(CCT_CALL* glAlphaFunc)(GLenum func, GLclampf ref);
		void(CCT_CALL* glBlendFunc)(GLenum sfactor, GLenum dfactor);
		void(CCT_CALL* glLogicOp)(GLenum opcode);
		void(CCT_CALL* glStencilFunc)(GLenum func, GLint ref, GLuint mask);
		void(CCT_CALL* glStencilOp)(GLenum fail, GLenum zfail, GLenum zpass);
		void(CCT_CALL* glDepthFunc)(GLenum func);
		void(CCT_CALL* glPixelZoom)(GLfloat xfactor, GLfloat yfactor);
		void(CCT_CALL* glPixelTransferf)(GLenum pname, GLfloat param);
		void(CCT_CALL* glPixelTransferi)(GLenum pname, GLint param);
		void(CCT_CALL* glPixelStoref)(GLenum pname, GLfloat param);
		void(CCT_CALL* glPixelStorei)(GLenum pname, GLint param);
		void(CCT_CALL* glPixelMapfv)(GLenum map, GLint mapsize, const GLfloat* values);
		void(CCT_CALL* glPixelMapuiv)(GLenum map, GLint mapsize, const GLuint* values);
		void(CCT_CALL* glPixelMapusv)(GLenum map, GLint mapsize, const GLushort* values);
		void(CCT_CALL* glReadBuffer)(GLenum mode);
		void(CCT_CALL* glCopyPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
		void(CCT_CALL* glReadPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);
		void(CCT_CALL* glDrawPixels)(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels);
		void(CCT_CALL* glGetBooleanv)(GLenum pname, GLboolean* params);
		void(CCT_CALL* glGetClipPlane)(GLenum plane, GLdouble* equation);
		void(CCT_CALL* glGetDoublev)(GLenum pname, GLdouble* params);
		GLenum(CCT_CALL* glGetError)();
		void(CCT_CALL* glGetFloatv)(GLenum pname, GLfloat* params);
		void(CCT_CALL* glGetIntegerv)(GLenum pname, GLint* params);
		void(CCT_CALL* glGetLightfv)(GLenum light, GLenum pname, GLfloat* params);
		void(CCT_CALL* glGetLightiv)(GLenum light, GLenum pname, GLint* params);
		void(CCT_CALL* glGetMapdv)(GLenum target, GLenum query, GLdouble* v);
		void(CCT_CALL* glGetMapfv)(GLenum target, GLenum query, GLfloat* v);
		void(CCT_CALL* glGetMapiv)(GLenum target, GLenum query, GLint* v);
		void(CCT_CALL* glGetMaterialfv)(GLenum face, GLenum pname, GLfloat* params);
		void(CCT_CALL* glGetMaterialiv)(GLenum face, GLenum pname, GLint* params);
		void(CCT_CALL* glGetPixelMapfv)(GLenum map, GLfloat* values);
		void(CCT_CALL* glGetPixelMapuiv)(GLenum map, GLuint* values);
		void(CCT_CALL* glGetPixelMapusv)(GLenum map, GLushort* values);
		void(CCT_CALL* glGetPolygonStipple)(GLubyte* mask);
		const GLubyte* (CCT_CALL* glGetString)(GLenum name);
		void(CCT_CALL* glGetTexEnvfv)(GLenum target, GLenum pname, GLfloat* params);
		void(CCT_CALL* glGetTexEnviv)(GLenum target, GLenum pname, GLint* params);
		void(CCT_CALL* glGetTexGendv)(GLenum coord, GLenum pname, GLdouble* params);
		void(CCT_CALL* glGetTexGenfv)(GLenum coord, GLenum pname, GLfloat* params);
		void(CCT_CALL* glGetTexGeniv)(GLenum coord, GLenum pname, GLint* params);
		void(CCT_CALL* glGetTexImage)(GLenum target, GLint level, GLenum format, GLenum type, GLvoid* pixels);
		void(CCT_CALL* glGetTexParameterfv)(GLenum target, GLenum pname, GLfloat* params);
		void(CCT_CALL* glGetTexParameteriv)(GLenum target, GLenum pname, GLint* params);
		void(CCT_CALL* glGetTexLevelParameterfv)(GLenum target, GLint level, GLenum pname, GLfloat* params);
		void(CCT_CALL* glGetTexLevelParameteriv)(GLenum target, GLint level, GLenum pname, GLint* params);
		GLboolean(CCT_CALL* glIsEnabled)(GLenum cap);
		GLboolean(CCT_CALL* glIsList)(GLuint list);
		void(CCT_CALL* glDepthRange)(GLclampd zNear, GLclampd zFar);
		void(CCT_CALL* glFrustum)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
		void(CCT_CALL* glLoadIdentity)();
		void(CCT_CALL* glLoadMatrixf)(const GLfloat* m);
		void(CCT_CALL* glLoadMatrixd)(const GLdouble* m);
		void(CCT_CALL* glMatrixMode)(GLenum mode);
		void(CCT_CALL* glMultMatrixf)(const GLfloat* m);
		void(CCT_CALL* glMultMatrixd)(const GLdouble* m);
		void(CCT_CALL* glOrtho)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
		void(CCT_CALL* glPopMatrix)();
		void(CCT_CALL* glPushMatrix)();
		void(CCT_CALL* glRotated)(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
		void(CCT_CALL* glRotatef)(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
		void(CCT_CALL* glScaled)(GLdouble x, GLdouble y, GLdouble z);
		void(CCT_CALL* glScalef)(GLfloat x, GLfloat y, GLfloat z);
		void(CCT_CALL* glTranslated)(GLdouble x, GLdouble y, GLdouble z);
		void(CCT_CALL* glTranslatef)(GLfloat x, GLfloat y, GLfloat z);
		void(CCT_CALL* glViewport)(GLint x, GLint y, GLsizei width, GLsizei height);

		//OpengGl 1.1
		void(CCT_CALL* glArrayElement)(GLint i);
		void(CCT_CALL* glBindTexture)(GLenum target, GLuint texture);
		void(CCT_CALL* glColorPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
		void(CCT_CALL* glDisableClientState)(GLenum array);
		void(CCT_CALL* glDrawArrays)(GLenum mode, GLint first, GLsizei count);
		void(CCT_CALL* glDrawElements)(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices);
		void(CCT_CALL* glEdgeFlagPointer)(GLsizei stride, const GLvoid* pointer);
		void(CCT_CALL* glEnableClientState)(GLenum array);
		void(CCT_CALL* glIndexPointer)(GLenum type, GLsizei stride, const GLvoid* pointer);
		void(CCT_CALL* glIndexub)(GLubyte c);
		void(CCT_CALL* glIndexubv)(const GLubyte* c);
		void(CCT_CALL* glInterleavedArrays)(GLenum format, GLsizei stride, const GLvoid* pointer);
		void(CCT_CALL* glNormalPointer)(GLenum type, GLsizei stride, const GLvoid* pointer);
		void(CCT_CALL* glPolygonOffset)(GLfloat factor, GLfloat units);
		void(CCT_CALL* glTexCoordPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
		void(CCT_CALL* glVertexPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
		GLboolean(CCT_CALL* glAreTexturesResident)(GLsizei n, const GLuint* textures, GLboolean* residences);
		void(CCT_CALL* glCopyTexImage1D)(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
		void(CCT_CALL* glCopyTexImage2D)(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
		void(CCT_CALL* glCopyTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
		void(CCT_CALL* glCopyTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
		void(CCT_CALL* glDeleteTextures)(GLsizei n, const GLuint* textures);
		void(CCT_CALL* glGenTextures)(GLsizei n, GLuint* textures);
		void(CCT_CALL* glGetPointerv)(GLenum pname, GLvoid** params);
		GLboolean(CCT_CALL* glIsTexture)(GLuint texture);
		void(CCT_CALL* glPrioritizeTextures)(GLsizei n, const GLuint* textures, const GLclampf* priorities);
		void(CCT_CALL* glTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid* pixels);
		void(CCT_CALL* glTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels);
		void(CCT_CALL* glPopClientAttrib)();
		void(CCT_CALL* glPushClientAttrib)(GLbitfield mask);
	};

	struct GlProcTable
	{
		int cEntries;
		WglDispatchTable WglDispatchTable;
	};

	using PFN_SetProcTable = void(CCT_CALL*)(const GlProcTable*);
} // namespace glgpus